#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_EXPRESSION_LENGTH 100
#define MAX_STACK_SIZE 100

typedef struct {
    char items[MAX_STACK_SIZE];
    int top;
} OperatorStack;

void initializeOperatorStack(OperatorStack *stack) {
    stack->top = -1;
}

bool isOperatorStackEmpty(OperatorStack *stack) {
    return stack->top == -1;
}

void pushOperator(OperatorStack *stack, char operator) {
    stack->items[++stack->top] = operator;
}

char popOperator(OperatorStack *stack) {
    if (!isOperatorStackEmpty(stack)) {
        return stack->items[stack->top--];
    }
    return '\0'; 
}

int getOperatorPrecedence(char operator) {
    if (operator == '+' || operator == '-') {
        return 1;
    } else if (operator == '*' || operator == '/') {
        return 2;
    }
    return 0; 
}

void infixToPostfix(char infixExpression[], char postfixExpression[]) {
    OperatorStack operatorStack;
    initializeOperatorStack(&operatorStack);

    int infixIndex = 0, postfixIndex = 0;
    
    while (infixExpression[infixIndex] != '\0') {
        char token = infixExpression[infixIndex];
        
        if (isalnum(token)) {
            postfixExpression[postfixIndex++] = token; 
        } else if (token == '(') {
            pushOperator(&operatorStack, token); 
        } else if (token == ')') {
            while (!isOperatorStackEmpty(&operatorStack) && operatorStack.items[operatorStack.top] != '(') {
                postfixExpression[postfixIndex++] = popOperator(&operatorStack); 
            }
            if (!isOperatorStackEmpty(&operatorStack) && operatorStack.items[operatorStack.top] == '(') {
                popOperator(&operatorStack); 
            }
        } else {
            while (!isOperatorStackEmpty(&operatorStack) && getOperatorPrecedence(operatorStack.items[operatorStack.top]) >= getOperatorPrecedence(token)) {
                postfixExpression[postfixIndex++] = popOperator(&operatorStack); 
            }
            pushOperator(&operatorStack, token); 
        }
        infixIndex++;
    }
    
    while (!isOperatorStackEmpty(&operatorStack)) {
        postfixExpression[postfixIndex++] = popOperator(&operatorStack); 
    }
    
    postfixExpression[postfixIndex] = '\0'; 
}


int evaluatePostfix(char postfixExpression[]) {
    OperatorStack operandStack;
    initializeOperatorStack(&operandStack);

    int index = 0;

    while (postfixExpression[index] != '\0') {
        char token = postfixExpression[index];

        if (isalnum(token)) {
            pushOperator(&operandStack, token - '0'); 
        } else {
            int operand2 = popOperator(&operandStack);
            int operand1 = popOperator(&operandStack);

            switch (token) {
                case '+':
                    pushOperator(&operandStack, operand1 + operand2);
                    break;
                case '-':
                    pushOperator(&operandStack, operand1 - operand2);
                    break;
                case '*':
                    pushOperator(&operandStack, operand1 * operand2);
                    break;
                case '/':
                    if (operand2 != 0) {
                        pushOperator(&operandStack, operand1 / operand2);
                    } else {
                        printf("Division by zero error.\n");
                        exit(1);
                    }
                    break;
            }
        }
        index++;
    }

    return popOperator(&operandStack);
}

int main() {
    char infixExpression[MAX_EXPRESSION_LENGTH];
    char postfixExpression[MAX_EXPRESSION_LENGTH];

    printf("Enter an infix expression: ");
    fgets(infixExpression, sizeof(infixExpression), stdin);
    
    if (infixExpression[strlen(infixExpression) - 1] == '\n') {
        infixExpression[strlen(infixExpression) - 1] = '\0';
    }

    infixToPostfix(infixExpression, postfixExpression);
    printf("Postfix expression: %s\n", postfixExpression);

    int result = evaluatePostfix(postfixExpression);
    printf("Result: %d\n", result);

    return 0;
}
